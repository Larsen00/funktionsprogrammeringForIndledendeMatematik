\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{pdfpages}
\input{Opsætning/Pakker}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib} % Erstat med stien til din .bib fil

% Definer en tilpasset kommando til at citere kun med titlen i en fodnote
\DeclareCiteCommand{\footcitetitle}[\mkbibfootnote]
  {\usebibmacro{prenote}} % Pre-note handler, her kan du indsætte information før selve citatet
  {\usebibmacro{citeindex}%
   \printtext[bibhyperref]{\mkbibbrackets{\printfield{labelnumber}}\addspace}% Tilføjer citatnummer i firkantede klammer og et mellemrum
   \printtext[bibhyperref]{\printfield{title}}} % Viser titlen efter nummeret
  {\multicitedelim} % Håndterer separator mellem flere citationer
  {\usebibmacro{postnote}} % Tilføjer post-note, bruges til at indsætte sidetal eller lignende efter citatet


\begin{document}
\input{Opsætning/forside}
\tableofcontents
\newpage



\newpage
\input{sections/Introduction.tex}
\newpage
\input{sections/Fundamentale_koncepter.tex}
\newpage
\input{sections/udtryk.tex}

\newpage
\input{sections/vektorer_og_matricer.tex}
\newpage
\input{sections/pbt.tex}

\section{Diskussion}
Vi begyndte rapporten med at informere læseren om, at Python er blevet indført som et hjælpemiddel i matematikkurserne på DTU. En af fordelene ved Python er klart, at det er et meget mere udbredt programmeringssprog, hvilket gør det nemmere at finde hjælp og vejledninger til opbygningen af et program eller løsning af en opgave. Under 1\% af udviklere i 2023 anvender F\#, hvilket er markant mindre end de næsten 50\% som bruger Python. Derfor har det været en udfordring i udviklingen af dette program at finde vejledning til de problemstillinger, der er opstået undervejs.

Derimod, eftersom F\# er et stærkt typet sprog, har det været markant nemmere at finde fejl i programmet inden det bliver kørt, hvilket er en af de store fordele ved F\# frem for Python og Ruby\footcitetitle{ruby}, som på mange måder ligner Python. Ruby er også det sprog, jeg arbejder med til daglig. Ruby tillader, ligesom Python, at kalde funktioner med objekter uden at definere en type for objektet, så længe objektet har de metoder, som funktionen forventer. Det medfører at man ofte skal tjekke om en metode er tilstede på et objekt, hvilket vi ikke behøver i F\#. Derudover kan objekter få tilføjet metoder under kørslen, hvilket kan have sine fordele, men som udvikler medfører det flere problemstillinger, blandt andet at når et objekt ikke har den forventede metode, vil programmet først fejle under kørslen. 

Mangel på typer sammenlignet med F\# betyder også, at det tager længere tid og kræver flere kommentarer at forstå, hvad et program gør. Denne udfordring har man ikke med F\#, så længe funktionsnavnet er sigende for, hvad funktionen gør. Kombineret med at kunne se, typen for funktionen, behøver man ofte ikke at læse selve koden for at forstå, hvad funktionen. Dette medførere, at man som udvikler kan være mere effektiv. Hvilket også giver rent performens mæssige fordele ved kørsel af et F\# program. 

Vedrørende syntaksen af F\# sammenlignet med Python/Ruby, er de mere kendt for at have en mere læsbar syntaks, hvilket gør dem mere begynder venlige. Især da F\#'s syntaks er forholdsvis anderledes end objektorienterede programmeringssprog. Dog ligger syntaksen for mange af funktionerne i dette program meget tæt op ad matematiske notationer, især grundet muligheden for nemt at kunne overskrive operatorer på egne typer. Netop det, at mange af funktionerne ligner de matematiske funktioner, gør, at implementeringen af dem burde medføre en bedre forståelse af, hvorfor mange af de metoder, man lærer at udføre i hånden er korrekte. Jeg har personligt fået en bedre forståelse af især matrixoperationer, og hvordan matrix-matrix produkt er bygget på matrix-vektor produkt. Sammenhængen mellem matematiske domæner og typerne i F\# gør, at man også kan forstå domæner fra et andet synspunkt, hvilket kan være med til at give en bedre forståelse herom.

Når det kommer til selve programmet, er der også både nogle udvidelser og forbedringer, der kunne laves. Først og fremmest fortrød jeg sent, at matricemodulet ikke var bygget med følgende typer i Listing \ref{lst:matrix_types_expr}.

\begin{lstlisting}[language={FSharp}, label={lst:matrix_types_expr}, caption={Eksempel på alternative typer for matrixmodulet}]
type Vector = V of list<Expr<Number>> * Order
type Matrix = M of list<Vector> * Order
\end{lstlisting}

Dette ville ikke have betydet store ændringer i funktionerne for modulet uden at ændre på funktionaliteten. Desuden ville det have gjort det nemmere at implementere løsninger til et lineært ligningssystem.

Modulet for komplekse tal kunne også have haft en polymorfisk type som i Listing \ref{lst:complex_type2}.

\begin{lstlisting}[language={FSharp}, label={lst:complex_type2}, caption={Eksempel på alternative typer for komplekse tal modulet}]
type Complex<'a, 'b> = C of 'a * 'b
\end{lstlisting}

Som ville medføre, at Number-typen ville blive:

\begin{lstlisting}[language={FSharp}, label={lst:number_type2}, caption={Eksempel på alternative typer for Number-typen}]
type Number = 
  | Int of int 
  | Rational of Rational 
  | Complex of Complex<Number, Number>
\end{lstlisting}

Denne ændring ville selvfølgelig medføre, at Number ville blive en rekursivt defineret type, hvilket skulle håndteres ansvarligt.
\section{Konklusion}
Det primære fokuspunkt for rapporten er, at en læser skulle opnå en bedre forståelse af matematiske koncepter gennem at opbygge et matematisk program ved hjælp af funktionsprogrammering. Min erfaring fra samtaler med mine medstuderende er, at rekursive funktioner generelt er et svært koncept for mange. Derfor tror jeg også, at introducere de studerende til rekursivitet gennem et funktionelt programmeringssprog som F\# ved hjælp af matematiske koncepter, som de møder i kurserne "01001 Matematik 1a" og "01002 Matematik 1b", vil gavne de studerendes forståelse af både matematikken og programmeringssproget. Derudover vil kendskabet til funktionsprogrammering forbedre de studerendes evne til at skrive bedre programmer, for eksempel i Python. Noget jeg ser hos mine medstuderende på "Matematik og Teknologi", som har lært at programmere i Python gennem de to grundlæggende matematikkurser, er blandt andet de ikke definerer funktioner for at genbruge kode. I stedet kopierer og indsætter de kode, hvilket ikke er en god praksis.


Selvom syntaksen for F\# kan være sværere at lære for nogle, tror jeg på, at gevinsten ved at lære den er stor.Implementeringen af dette program, fra hvordan man udfører operationer af komplekse tal til hvordan man ud fra simple matematiske regler kan simplificere udtryk, vil gavne forståelsen af matematikken. De studerende vil forstå, hvorfor diverse funktioner virker. Hvilket ikke altid er tilfældet i Python, hvor mange funktioner kan håndteres som en sort boks.


Konklusionen er, at F\# måske ikke vil kunne erstatte Python i matematikkurserne på DTU, men det vil kunne være et godt supplement til at forbedre de studerendes forståelse af matematikken og programmering.


\newpage
\printbibliography

\newpage
\input{sections/Appendiks.tex}
\end{document}
