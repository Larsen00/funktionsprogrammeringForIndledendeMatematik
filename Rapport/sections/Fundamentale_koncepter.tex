
\section{Fundamentale koncepter}
\subsection{Introduktion til Funktions Programmering}
Det forventes, at læseren har kendskab til programmering. Der gives derfor kun en kort beskrivelse af syntaks og notation, så læsere, der ikke er bekendt med F\#, kan forstå de eksempler, der løbende vil forekomme i rapporten. Vi begynder derfor med at betragte funktionen for fakultet Ligning \eqref{Fakultet}.

\begin{equation}
    \label{Fakultet}
    f(n) = \begin{cases} 
            1 &  n = 0  \\
            n \cdot f(n-1) & n > 0 \\
            \text{undefined} & n < 0 
           \end{cases}
\end{equation}

Et eksempel på en implementering i F\# er givet i Listing \ref{lst:fsharp_factorial}, som kan sammenlignes med Python-koden i Listing \ref{lst:python_factorial}, da Python og pseudokode er næsten det samme.


\begin{lstlisting}[language={FSharp}, label={lst:fsharp_factorial}, caption={Eksempel på Fakultet i F\#}]
// Fakultet i F#
let rec factorial n =
    match n with
    | 0             -> 1 
    | x when x > 0  -> x * factorial (x - 1)
    | _             -> failwith "Negative argument"
\end{lstlisting}

\begin{lstlisting}[language={FSharp}, label={lst:python_factorial}, caption={Eksempel på Fakultet i Python}]
# Fakultet i Python
def factorial(n):
    if n == 0:
        return 1
    elif n > 0:
        return n * factorial(n - 1)
    else:
        raise ValueError("Negative argument")
\end{lstlisting}

I F\# anvendes \textcolor{blue}{let} til at definere en ny variabel eller, i dette tilfælde, en funktion kaldet \textcolor{red}{factorial}. Næste nøgleord er \textcolor{blue}{rec}, hvilket indikerer, at funktionen er rekursiv. Funktionen tager et inputargument \(n\), og i linje 3 starter et match-udtryk. Her er \(n\) vores udtryk, og efter \textcolor{codepurple}{with} begynder en række mønstre, som udtrykket forsøger at matche på, separeret med '\(\vert\)'. Resultatet af funktionen vil være den kode, der eksekveres efter '\(\rightarrow\)', på den linje, hvor mønsteret er genkendt.
    
I F\#, er det som udgangspunkt ikke nødvendigt at anvende parenteser som i andre programmeringssprog. Derfor vil de kun blive anvendt, hvor det er nødvendigt gennem rapporten, typisk i sammenhænge med kædning af funktioner. For at undgå brugen af parenteser kan man i F\# benytte pipe-operatorerne, $|>$ og $<|$, som fører resultatet fra en udledning direkte ind i den næste funktion. Nedenstående eksempel viser tre ækvivalente udtryk, der demonstrerer anvendelsen af disse operatorer.

\begin{lstlisting}[style=output, label={lst:pipe_operator}, caption={Eksempel på anvendelse af pipe-operatorer i F\# ved udregning af $(3!)! = 6! = 720 $.}]
> factorial (factorial 3);;
val it: int = 720

> factorial <| factorial 3;;
val it: int = 720

> factorial 3 |> factorial;;
val it: int = 720
\end{lstlisting}


% Et match på et mønster er ikke det samme som '==' kendt fra andre programmeringssprog. I linje 4 forsøger den at tildele værdien af \(n\) til 0, og dette lykkes kun, hvis \(n\) er 0. Hvis \(n\) ikke er 0 og dermed ikke genkender linje 4, vil den forsøge at genkende det næste mønster. Her står der kun \(x\), da der ikke yderligere specificeres om netop \(x\), vil det altid lykkes, og \(x\) bliver tildelt værdien af \(n\) svarende til \( [x \mapsto n] \). Derefter skal betingelserne efter \textcolor{codepurple}{when} være opfyldt. Hvis de er det, kan mønsteret genkendes på den givne linje. Derefter eksekverer den koden efter '$\rightarrow$', hvor den samtidig har adgang til den nyligt tildelte værdi af \(x\). 
% Det sidste mønster på linje 6 anvender '\textunderscore' som mønster. 
% Dette betyder, at det kan genkende alle udtryk, men vi er ikke interesseret i at anvende værdien. I dette tilfælde kan det tredje mønster på linje 6 kun køres, når \(n\) er negativ.


\subsection{Typer}
I F\#, i modsætning til Python, er typer tildelt ved kompileringstidspunktet, ikke under kørsel. Alle udtryk, inklusiv funktioner, har en defineret type. Typen for funktionen i Listing \textcolor{red}{\ref{lst:fsharp_factorial}} er $int \rightarrow int$. Det betyder, at det ikke er muligt at kalde funktionen med et argument, der ikke er af typen $int$. Typen for funktionen beskrives som $Factorial: int \rightarrow int$. Det ses dermed tydeligt hvordan f\# benytter notationen for afbildninger i mattematik, da den matematiske funktion for fakultet er en afbildning $f: \mathbb{Z} \to \mathbb{Z}$. Vi kan derfor formulere følgende omkring typer\footcitetitle[14]{HansenRischelFSharp}:
\begin{gather*}
    f: T_1 \rightarrow T_2 \\
    f(e) : T_2 \iff e : T_1
\end{gather*}
% => f(e) ville give en fejl, hvis ikke e er af typen T1
% <= per definition, så er f(e) : T2, hvis e : T1

Hvis en funktion kaldes med et argument, der ikke matcher funktionens type, genereres en fejlmeddelelse. Derudover kan en type også bestå af en tuple af typer:
\begin{gather*}
    f: T_1 * T_2 * .. * T_n \rightarrow T_{n+1}\\
    f (e_1, e_2, .., e_n) :T_{n+1} \iff e_1 : T_1 \land e_2 : T_2 \land .. \land e_n : T_n
\end{gather*}
En tuple, der kun består af to typer, kaldes et par. Givet en funktion $g: T_1 \rightarrow T_2 \rightarrow T_3$, betyder dette, at den tager et udtryk af typen $T_1$, som giver en funktion af typen $T_2 \rightarrow T_3$, hvor evalueringen af funktionen resulterer i $T_3$. Som eksempel på dette kan vi definere en multivariable funktion $f(x, y) = \sqrt{x! + y!}$ som er en afbildning $f: \mathbb{Z}^2 \to \mathbb{R}$ samt $g(y) = f(3, y) = \sqrt{3! + y!}$ som afbilder $g: \mathbb{Z} \to \mathbb{R}$, de tilsvarende F\# funktion kan defineres på følgende måder:
\begin{lstlisting}[language={FSharp}, label={lst:multivariable_function}, caption={Eksempel typerne for en multivariable funktion i F\#}]
// f: int -> int -> float
let f x y = sqrt <| float(factorial x + factorial y)

// g: int -> float
let g = f 3
\end{lstlisting}





\subsection{Signatur filer og implementerings filer}
En standard F\# fil er lavet med .fs extension, denne fil indeholder alt den kode som er nødigt for at kunne køre programmet. En implementerings fil kan have en signatur fil med .fsi extension, denne fil indeholder en beskrivelse af de typer og funktioner i implementerings filen som er tilgængelige for andre filer. En signatur fil kan derfor bruges som et blueprint for andre der ønsker at anvende eller replicere implementerings filen. I andre programmerings sprog vil man anse funktionerne i signatur filen som værende "public" og de funktioner der ikke er i signatur filen, men er i implementerings filen som værende "private". 

\subsection{Overloading af operatorer}
I F\# er det muligt at overskrive standardoperatorer, så de kan anvendes på egne typer. Denne teknik vil blive benyttet igennem rapporten til at definere matematiske operationer for de typer, vi udvikler.

\subsection{Property Based Testing}
Property Based Test (PBT) er en teknik til at teste korrekthed af egenskaber som man ved altid skal være opfyldt. Ved PBT genereres en række tilfældige input til en funktion, hvorefter det kontrolleres, om en given egenskab holder. 

På DTU lærer de matematiske studerende først om logik, hvor det introduceres, at en udsagnslogisk formel er gyldig (en tautologi), hvis den altid er sand. Der findes mange teknikker til at påvise gyldigheden af en udsagnslogisk formel. I de indledende matematiske kurser på DTU lærer man at anvende sandhedstabeller, som demonstrerer gyldigheden af en formel. Eksempelvis vises hvordan \ref{udsagnslogik} er gyldig.
\begin{gather}
    P \land (Q \land R) \iff (P \land Q) \land R
    \label{udsagnslogik}
\end{gather}

Vi kan også bruge PBT til at undersøge, om (\ref{udsagnslogik}) holder, ved at definere egenskaben som en funktion af $P, Q$ og $R$, som vist i Listing 3 (\ref{valid1}).

\lstinputlisting[
    language=FSharp,
    label={valid1},
    caption={PBT af ligning \ref{udsagnslogik}. Begge sider er omgivet af parenteser da $=$ har en højere præcedens end $\&\&$}
]{exampleCodes/valid1.fsx}

\begin{lstlisting}[style=output, label={lst:output_example}, caption={Output ved PBT af (\ref{udsagnslogik})}]
> let _ = Check.Quick propositional_formula;;
Ok, passed 100 tests.
\end{lstlisting}

Check.Quick er en del af "FsCheck" biblioteket, den tager en funktion som argument, og generere en række tilfældige input til funktionen på baggrund af funktionens type. Hvis funktionen returnere "true" for alle input, vil testen lykkedes. Hvis funktionen returnere "false" for et input, vil testen fejle og give et eksempel på et input der fejlede. I Listing \ref{valid1} er der anvendt "Check.Quick" til at teste om (\ref{udsagnslogik}) er gyldig. Funktionen "Check.Quick" returnere "Ok, passed 100 tests." hvilket indikerer at (\ref{udsagnslogik}) er gyldig. Det vigtigt her at forstå dette ikke er det samme som at bevise at den er gyldig, da ikke alle muligheder er blevet testet. 
I nogle tilfælde vil det være en fordel at opskrive en PBT før implementeringen af en funktion som man ved skal overholde en egenskab, på den måde anvende Test Driven Development (TDD) \footcitetitle{TDD} til at teste om ens egenskab forbliver overholdt, under implementering.
