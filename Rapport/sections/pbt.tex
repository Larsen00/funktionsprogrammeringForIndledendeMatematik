\section{PBT af programmet} 
\subsection{PBT af udtryk}
Før vi begynder at udføre PBT på alle egenskaber vedrørende udtryk, skal vi først bygge en generator for vores talmængde og udtryk. Da vi ikke altid kan sammenligne, om to udtrykstræer er ækvivalente, vil vi i alle vores PBT, hvor vi ønsker at sammenligne træer, gøre dette ved brug af et miljø, som indeholder værdier for variablene, og derefter evaluere udtrykene ved brug af \textcolor{red}{eval}-funktionen.

Vi begynder med at definere en række generatorer, som kan generere blade i vores udtrykstræer i Listing \ref{generator1}.


\begin{lstlisting}[
    language={FSharp}, 
    label={generator1}, 
    caption={Generatorene anvendt til PBT af udtryk}
    ]
let max = 3
let min = -3

// noneZeroGen: Gen<int>
let noneZeroGen = 
    Gen.oneof [ 
        Gen.choose(1, max) ;
        Gen.choose(min, -1)]

// numberGen: Gen<Number>
let numberGen =
    Gen.oneof [
        Gen.map2 (fun x y -> newRational(x, y) |> Rational |> tryReduce ) (Gen.choose(min, max)) noneZeroGen;
        Gen.map (fun x -> Int x) (Gen.choose(min, max));
        Gen.map4 (fun a b c d -> newComplex (newRational(a, b), newRational(c, d)) |> Complex |> tryReduce ) (Gen.choose(min, max)) noneZeroGen (Gen.choose(min, max)) noneZeroGen]

// numberInExprGen: Gen<Expr<Number>>
let numberInExprGen = 
    Gen.map (fun x -> N x) numberGen

// randomListElement: list<'a> -> Gen<'a>
let randomListElement xlist = 
    gen { let! i = Gen.choose(0, List.length xlist - 1)
        return xlist.[i] }

// variableGen: list<char> -> Gen<Expr<'a>>
let variableGen xlist = Gen.map X (randomListElement xlist)

// leafGen: list<char> -> Gen<Expr<Number>>
let leafGen xlist =
    if xlist <> [] then
        Gen.oneof [numberInExprGen; variableGen xlist]
    else
        numberInExprGen

// onlyIntleafGen: list<char> -> Gen<Expr<Number>>
let onlyIntleafGen xlist :Gen<Expr<Number>> = 
    if xlist <> [] then
        Gen.oneof [Gen.map (fun x -> N <| Int x) (Gen.choose(-10, 10)); variableGen xlist]
    else
        Gen.map (fun x -> N <| Int x) (Gen.choose(-10, 10))

// charsSeqGen: char -> char -> seq<Gen<char>>
let charsSeqGen c1 c2 = seq { for c in c1 .. c2 do
                                yield gen { return c} }

// charGen: Gen<char>
let charGen = gen { return! Gen.oneof (charsSeqGen 'A' 'Z')}

// smallEnvGen: Gen<Map<char, Number> * list<char>>
let smallEnvGen =
    gen { 
        let! i = Gen.choose (0, 5)
        let! xlist = Gen.listOfLength i charGen
        let! ns = Gen.listOfLength i numberGen
        return (Map.ofList (List.zip xlist ns), xlist) }

// exprGen: 'a -> int -> ('a -> Gen<Expr<'b>>) -> Gen<Expr<'b>> 
let rec exprGen xlist n leafType = 
    if n = 0 then
        leafType xlist
    else
        Gen.oneof [
            // leaf occurs twice becourse leaf is X or N giving the same probability for each expression 
            leafType xlist; 
            leafType xlist;
            Gen.map2 (fun x y -> Add (x, y)) (exprGen xlist (n/2) leafType) (exprGen xlist (n/2) leafType);
            Gen.map2 (fun x y -> Mul (x, y)) (exprGen xlist (n/2) leafType) (exprGen xlist (n/2) leafType);
            Gen.map2 (fun x y -> Div (x, y)) (exprGen xlist (n/2) leafType) (exprGen xlist (n/2) leafType);
            Gen.map2 (fun x y -> Sub (x, y)) (exprGen xlist (n/2) leafType) (exprGen xlist (n/2) leafType);            
            Gen.map (fun x -> Neg x) (exprGen xlist (n/2) leafType)]


type SmallEnv = Map<char, Number> * char list
type SmallEnvGen =
    static member SmallEnv() =
        {new Arbitrary<SmallEnv>() with
            override _.Generator = smallEnvGen
            override _.Shrinker _ = Seq.empty}

type NumberGen =
static member Number() =
    {new Arbitrary<Number>() with
        override _.Generator = numberGen
        override _.Shrinker _ = Seq.empty}    
\end{lstlisting}

Vi begynder med at definere to variable, som alle funktioner har til rådighed, \texttt{max} og \texttt{min}, som definerer intervallet for de heltal, der kan anvendes i genereringen af Numbers. 
Den første funktion, \textcolor{red}{noneZeroGen}, er en generator for et tilfældigt heltal fra sættet $S_1$:
\begin{gather*}
    S_1 = \{ x \mid x \in \mathbb{Z} \setminus \{0\}, \quad \texttt{min} \leq x \leq \texttt{max} \}.
\end{gather*}
Vi kan dermed bruge \textcolor{red}{noneZeroGen}, da vi ikke ønsker at generere rationale tal med nævneren 0. For at definere en generator for Numbers i form af \textcolor{red}{numberGen}, som genererer et gyldigt Number fra sættet $S_5$:
\begin{align*}
    S_2 &= \left\{ x \mid x \in \mathbb{Z}, \quad \texttt{min} \leq x \leq \texttt{max} \right\} \\
    S_3 &= \left\{ \frac{x}{y} \mid x \in S_1, y \in S_2 \right\} \\
    S_4 &= \left\{ x + yi \mid x, y \in S_3 \right\} \\
    S_5 &= S_2 \cup S_3 \cup S_4
\end{align*}

Funktionen \textcolor{red}{numberInExprGen} er en generator, som ved brug af \textcolor{red}{numberGen} konverterer et \texttt{Number} til et \texttt{Expr<Number>}. Det er disse generatorer, der anvendes til at generere tal til vores talmængde.

Dernæst kommer nogle generatorer til generering af variable. Først har vi \textcolor{red}{randomListElement}, som tager en liste af en vilkårlig type og udvælger et tilfældigt element fra listen. Derudover har vi \textcolor{red}{variableGen}, som tager en liste af karakterer og bruger \textcolor{red}{randomListElement} til at udvælge en af karaktererne og konvertere den til et \texttt{Expr<Number>}.

Dermed er det nu muligt at lave en generator, som kan generere enten et tal eller en variabel fra konstruktørerne af \texttt{Expr<Number>}. Disse to konstruktører er også bladene i vores udtrykstræer. \textcolor{red}{leafGen} genererer et tilfældigt blad i vores udtrykstræ ud fra en liste af karakterer. \textcolor{red}{onlyIntleafGen} fungerer ud fra det samme princip, men genererer kun heltal fra intervallet -10 til 10.

Funktionerne \textcolor{red}{charGen} og \textcolor{red}{charsSeqGen} er generatorer, som sammen genererer en tilfældig karakter mellem 'A' og 'Z'. Endelig har vi en miljøgenerator, \textcolor{red}{smallEnvGen}, som genererer et par af et miljø samt liste af variable i miljøet. Miljøet indeholder variable og deres tilsvarende værdier.

Den sidste generator, \textcolor{red}{exprGen}, vil i vores PBT tage en liste af variable, som den må generere blade ud fra, samt hvilken generator der skal anvendes til at generere bladene. Derudover vil den maksimale dybde af udtrykket være \(\log_2(n)\).

Til sidst defineres tre typer, hvor \texttt{SmallEnvGen} og \texttt{NumberGen} gør det muligt inden kørsel af vores PBT at registrere generatorerne.

Vi har dermed nu lavet fundamentet, til at kunne teste vores egenskaber vedrørende udtryk.

\subsubsection{Tal modulet}\label{sec:PBT_number}
De 6 egenskaber fra \ref{egenskab:tal} kan nu testes med PBT. Egenskaberne kan oversættes direkte til funktioner, grundet de overskrivninger vi har lavet på number typen i Listing \ref{pbt:number}. 

\lstinputlisting[
    language=FSharp, 
    caption={\textit{numberPBT.fsx} - funktioner til test af egenskaberne i \ref{egenskab:tal}},
    label={pbt:number}
    ]{../PBT/numberPBT.fsx}
I \textcolor{red}{inverseMultiplicative} anvender vi "Prop.classify" til at tillade, at egenskaben kan slå bestemte fejl. I dette tilfælde tillades det, at der opstår en "DivideByZeroException". Dette sker, fordi generatoren godt kan generere 0, som der ikke kan tages en invers af. For at teste ovensånde funktioner, køres \textit{.fsx} filen, og outputtet kan ses i Listing \ref{output:number}.
\begin{lstlisting}[
    style=output, 
    label={output:number}, 
    caption={Outputtet fra PBT af Number typer, ved kørsel af Listing \ref{pbt:number}}
    ]        
Ok, passed 100 tests.
Ok, passed 100 tests.
Ok, passed 100 tests.
Ok, passed 100 tests.
Ok, passed 100 tests.
Ok, passed 100 tests.
94% PropertyHolds.
6% DivideByZeroExceptions.
\end{lstlisting}

Dermed viser testen at alle egenskaberne fra \ref{egenskab:tal} holder. 

\subsubsection{Homomorfisme af evaluering}\label{sec:PBT_eval_homomorphism}

Vi skal nu teste egenskaben fra \ref{prop:eval_homomorphism}. Testen er lavet i Listing \ref{pbt:eval_homomorphism}. Dette er gjort ved, at der genereres et tilfældigt miljø, hvori der samples to udtryk ud fra variablene i miljøet. For alle operatorer testes det, om de overholder egenskaben om homomorfisme.


\begin{lstlisting}[
    language={FSharp}, 
    label={pbt:eval_homomorphism}, 
    caption={PBT af egenskaben omkring Homomorfisme fra \ref{prop:eval_homomorphism}}
    ]
// evalOperation: Expr<Number> -> Expr<Number> -> Map<char, Number> -> (Expr<Number> -> Expr<Number> -> Expr<Number>) -> bool
let evalOperation e1 e2 env f =
eval (f e1 e2) env = (getNumber <| f (eval e1 env |> N) (eval e2 env |> N))
 
let evalPBT ((env ,xlist):SmallEnv) = 
    let result = 
        try
            let exprList = Gen.sample 1 2 (exprGen xlist 10 leafGen)
            let e1::[e2] = exprList
            let prop = evalOperation e1 e2 env
            let negation = eval (-e1) env = - eval e1 env
            if negation && prop ( + ) && prop ( - ) && prop ( * ) && prop ( / ) then 1 else 0
        with
        | :? System.DivideByZeroException as _ -> 2
        | :? System.OverflowException as _ -> 3
    (result = 1 || result = 2 || result = 3)
    |> Prop.classify (result = 1) "Property Holds"
    |> Prop.classify (result = 2) "DivideByZeroExceptions"
    |> Prop.classify (result = 3) "OverflowException"    
\end{lstlisting}

Outputtet fra testen kan ses i Listing \ref{output:eval_homomorphism}. Testen viser, at egenskaben holder for alle operationer.

\begin{lstlisting}[
    style=output, 
    label={output:eval_homomorphism}, 
    caption={Outputtet fra PBT af egenskaben \ref{prop:eval_homomorphism}}
    ]
> Arb.register<SmallEnvGen>()
- let _ = Check.Quick evalPBT;;
Ok, passed 100 tests.
76% Property Holds.
18% DivideByZeroExceptions.
6% OverflowException.
\end{lstlisting}
Vi ser her en større mængde af tests, som bliver klassificeret som "DivideByZeroExceptions". Dette skyldes, at vores generator godt kan generere udtryk som \(1/(0 \cdot X)\) og lignende, hvilket ikke er et lovligt udtryk. Derudover forekommer der også "OverflowExceptions", hvilket skyldes, at ved evaluering af udtryk kan vi godt ende med en kombination af operationer, som giver rationale tal, der, som beskrevet i sektion \ref{sec:rational}, kan resultere i en overflow. Samme form for klassificeringer vil vi løbende se i de kommende tests.



\subsubsection{Simplifikation af udtryk}\label{sec:PBT_simplification}
Det er vigtigt, at vores simplifikation altid er lig med det oprindelige udtryk. Vi kan derfor teste egenskab \ref{egenskab:simplification} ved at simplificere et udtryk og sammenligne evalueringen af det med det oprindelige udtryk ved hjælp af et miljø. Dette er gjort i Listing \ref{pbt:simplification}.

\begin{lstlisting}[language={FSharp}, caption={PBT af egenskaben \ref{egenskab:simplification}}, label={pbt:simplification}]
// compareSimpExpr: Map<char, Number> -> Expr<Number> -> bool
let compareSimpExpr env (e:Expr<Number>) =
    eval (simplifyExpr e) env = eval e env

// simpEqualEval: SmallEnv -> int
let simpEqualEval (env, xlist) = 
    try
        if Gen.sample 1 1 (exprGen xlist 10 leafGen) 
            |> List.head 
            |> compareSimpExpr env 
        then 1 else 0
    with
        | :? System.DivideByZeroException as _ -> 2
        | :? System.OverflowException as _ -> 3

// simpPBT: SmallEnv -> Property
let simpPBT (se:SmallEnv) =
    let result = simpEqualEval se
    (result = 1 || result = 2 || result = 3)
    |> Prop.classify (result = 1) "Equal"
    |> Prop.classify (result = 2) "DivideByZeroExceptions"
    |> Prop.classify (result = 3) "OverflowException"   
\end{lstlisting}

Outputtet fra testen kan ses i Listing \ref{output:simplification}. Testen viser, at egenskaben holder.

\begin{lstlisting}[
    style=output, 
    label={output:simplification}, 
    caption={Outputtet fra PBT af egenskaben \ref{egenskab:simplification}}
    ]
> Arb.register<SmallEnvGen>()
- let _ = Check.Quick simpPBT;;
Ok, passed 100 tests.
94% Equal.
6% DivideByZeroExceptions.
\end{lstlisting}

\subsubsection{Invers morfisme mellem infix og prefix}\label{sec:PBT_infix_prefix}
Nu skal det undersøges, hvorvidt egenskab \ref{egenskab:infix_prefix} holder. Vi beskrev i Listing \ref{lst:expression_to_infix} den inverse funktion til \textcolor{red}{tree}-funktionen, som benyttes til at opskrive egenskaben i Listing \ref{pbt:infix_prefix}.

\begin{lstlisting}[language={FSharp}, caption={PBT af egenskaben \ref{egenskab:infix_prefix}}, label={pbt:infix_prefix}]
// generatesCorrectTree: Map<char, Number> -> Expr<Number> -> bool
let generatesCorrectTree env (e:Expr<Number>) =
    eval e env = eval 
        (simplifyExpr e 
        |> infixExpression 
        |> tree 
        |> infixExpression 
        |> tree ) env

// treeEqualEval: SmallEnv -> int
let treeEqualEval (env, xlist) =
    try 
        if Gen.sample 1 1 (exprGen xlist 10 onlyIntleafGen) 
            |> List.head 
            |> generatesCorrectTree env 
        then 1 else 0
    with
        | :? System.DivideByZeroException as _ -> 2
        | :? System.OverflowException as _ -> 3

// treePBT: SmallEnv -> Property
let treePBT (se:SmallEnv) =
    let result = treeEqualEval se
    (result = 1 || result = 2 || result = 3)
    |> Prop.classify (result = 1) "Equal"
    |> Prop.classify (result = 2) "DivideByZeroExceptions"
    |> Prop.classify (result = 3) "OverflowException"
\end{lstlisting}

Funktionen \textcolor{red}{generatesCorrectTree} tager et miljø samt et udtryk og undersøger, om:
\begin{gather}
    \text{eval}(e) = \text{eval}(\text{tree}(\text{tree}^{-1}(\text{tree}(\text{tree}^{-1}(\text{simplifyExpr}(e))))))
\end{gather}
Det er gjort på denne måde, da det ikke er muligt igennem vores program at generere matematiske udtryk i infix-notation, som med sikkerhed har gyldig notation. I stedet vil vi anvende vores udtryksgenerator til at generere et udtryk, som vi så ved hjælp af et miljø kan tjekke, at egenskaben \ref{egenskab:infix_prefix} holder for alle \( x \in \texttt{Expr<Number>} \). 

Udtrykket bliver simplificeret, før det konverteres til infix-notation, da der er valgt ikke at placere parenteser rundt om tal i udtrykket, for visualiseringens skyld. Dette betyder, at hvis udtrykket ikke simplificeres, kan der skabes udtryk som \texttt{Neg(N -1)}, som i infix-notation er \(--1\), hvilket ikke er en gyldig notation uden parenteser. Simplifikationen sørger for, at negative tal repræsenteres ved negationen af et positivt tal.
 

Outputtet fra kørsel af testen kan ses i Listing \ref{output:infix_prefix}. Testen viser som forventet, at egenskaben holder for alle udtryk.
\begin{lstlisting}[
    style=output, 
    label={output:infix_prefix}, 
    caption={Outputtet fra PBT af egenskaben \ref{egenskab:infix_prefix}}
    ]
> Arb.register<SmallEnvGen>()                               
- let _ = Check.Quick treePBT;;
Ok, passed 100 tests.
94% Equal.
6% DivideByZeroExceptions.
\end{lstlisting}


\subsubsection{Differentiering af udtryk}\label{sec:PBT_differentiation}
Selv om differentieringsfunktionen \textcolor{red}{diff} er implementeret ud fra egenskaberne i \ref{egenskab:differentiation}, er det stadig vigtigt at teste, om funktionen overholder de samme egenskaber. Dette er gjort i \textit{diffPBT.fsx}, se Listing \ref{pbt:differentiation}.

\lstinputlisting[language=FSharp, caption={\textit{diffPBT.fsx} - funktioner til test af egenskaberne i \ref{egenskab:differentiation}}, label={pbt:differentiation}]{../PBT/diffPBT.fsx}

Outputtet fra kørsel af testen kan ses i Listing \ref{output:differentiation}. Testen viser, at egenskaberne holder.

\begin{lstlisting}[style=output, caption={Outputtet fra PBT af differentiering af udtryk}, label={output:differentiation}]
Differentiation property based testing
Ok, passed 100 tests.
72% Property Holds.
15% DivideByZeroExceptions.
13% OverflowException.
\end{lstlisting}



\subsection{PBT af vektorer og matricer}
Ligesom ved PBT af udtryk begynder vi med at lave end generatorer for matricer.

\begin{lstlisting}[
    language={FSharp}, 
    label={generators}, 
    caption={Generatorerne anvendt til PBT af matrixoperationer}
    ]
// vectorGen : int -> Gen<Vector>
let vectorGen n =
    Gen.listOfLength n numberGen |> Gen.map (fun x -> vector x)

// matrixGen : Gen<Matrix>
let matrixGen =
    gen {
        let! row = Gen.choose(1, 6)
        let! col = Gen.choose(1, 6)
        let! vectors = Gen.listOfLength col (vectorGen row)
        return matrix vectors
    }

type MatrixGen =
    static member Matrix() =
        {new Arbitrary<Matrix>() with
            override _.Generator = matrixGen
            override _.Shrinker _ = Seq.empty}
\end{lstlisting}

Først defineres \textcolor{red}{vectorGen}, som laver en liste ved hjælp af den tidligere definerede funktion \textcolor{red}{numberGen}. Den laver en liste med en given længde af tilfældige tal fra vores talmængde. Dernæst passes listen videre til \textcolor{red}{vector}-funktionen, som laver en søjlelagret vektor ud fra listen. Funktionen \textcolor{red}{matrixGen} genererer en matrix af tilfældig størrelse, hvor antallet af rækker og kolonner er mellem 1 og 6 ved hjælp af \textcolor{red}{vectorGen}. Til sidst kan vi definere en type for matrixgeneratorerne, som gør det muligt at registrere dem før kørsel af PBT.

\subsubsection{PBT af matrix operationer}
Det er nu muligt at opstille nogle PBT af der sikre at matricerne overholder matematiske egenskaber i sætning \ref{vector_space_axioms}. 




Vi kan dermed nu lave definere egenskaberne fra \ref{vector_space_axioms} som nogle funktioner i Listing \ref{lst:vector_space_axioms}.

\begin{lstlisting}[
    language={FSharp}, 
    label={lst:vector_space_axioms}, 
    caption={Egenskaberne fra sætning \ref{vector_space_axioms} som funktioner}
    ]
//vectorCom : Matrix -> bool
let vectorCom m =
    sumRows m = sumRows (flip m)

//vectorScalarAss : Matrix -> Number -> Number -> bool
let vectorScalarAss (m:Matrix) (n1:Number) (n2:Number) =
    n1 * (n2 * m) = (n1 * n2) * m

//vectorAssCom : Matrix -> Number -> bool
let vectorAssCom m (c:Number) =
    c * (sumRows m) = sumRows (c * m)
\end{lstlisting}

Listing \ref{lst:vector_space_axioms_pbt} viser outputtet fra kørsel af testene. Testene viser, at egenskaberne holder for alle matricer.

\begin{lstlisting}[
    style=output, 
    label={lst:vector_space_axioms_pbt}, 
    caption={Outputtet fra PBT af vektor Listing \ref{lst:vector_space_axioms}}
    ]
- Arb.register<MaxtrixGen>()
- let _ = Check.Quick vectorCom
- let _ = Check.Quick vectorScalarAss
- let _ = Check.Quick vectorAssCom;;
Ok, passed 100 tests.
Ok, passed 100 tests.
Ok, passed 100 tests.
\end{lstlisting}

\subsubsection{PBT af Gram-Schmidt}\label{sec:pbt_gram_schmidt}
Udfrodringen ved at lave en PBT af Gram-Schmidt er at vektorsættet skal være lineært uafhængige. Derfor laves der en generator som ved at udføre tilfældige række operationer på en matrix , kan generere en matrix med lineært uafhængige vektorer. 

\begin{lstlisting}[
    language={FSharp}, 
    label={generators_gram_schmidt}, 
    caption={Generatorene anvendt til PBT af Gram-Schmidt}
    ]
// getBacismatrixGen : int -> Gen<Matrix>
let getBacismatrixGen n =
    Gen.map (fun x -> standardBacis x) (Gen.choose (2, n))

// performRowOperationGen : Matrix -> Gen<Matrix>
let performRowOperationGen m =
    let (D(n, _)) = dimMatrix m
    gen { 
        let! i = Gen.choose(1, n)
        let! j = match i with
            | 1 -> Gen.choose(2, n)
            | _ when i = n -> Gen.choose(1, n-1)
            | _ -> Gen.oneof [
                    Gen.choose(1, i-1); 
                    Gen.choose(i+1, n)]
        let! a = numberGen
        return rowOperation i j a m }


// multipleRowOperationsGen : Matrix -> int -> Gen<Matrix>
let rec multipleRowOperationsGen m count =
    if count <= 0 then Gen.constant m
    else
        gen {
            let! newMatrix = performRowOperationGen m
            return! multipleRowOperationsGen newMatrix (count - 1)
        }

// getIndependetBacisGen : Gen<Matrix>
let getIndependetBacisGen =
    gen { 
        let! m = getBacismatrixGen 5
        let! numberOfOperations = Gen.choose(1, 10)
        let! span = multipleRowOperationsGen m numberOfOperations
        return span }

type IndependetBacis = Matrix
type IndependetBacisGen =
    static member IndependetBacis() =
        {new Arbitrary<Matrix>() with
            override _.Generator = getIndependetBacisGen
            override _.Shrinker _ = Seq.empty}
\end{lstlisting}

Listing \ref{generators_gram_schmidt} viser de forskellige generatorer, som anvendes til PBT (Property-Based Testing) af Gram-Schmidt-processen. Først genereres en tilfældig basis matrix. Dernæst udvælges to tilfældige rækker, \(i\) og \(j\), hvorefter der udføres en rækkeoperation på \(R_j\), således at \(R_j \leftarrow R_j - aR_i\), hvor $a$ er et tilfældigt Number. Denne proces gentages et tilfældigt antal gange.

Dernæst skal vi bruge en funktion til at tjekke om en matrix er en ortogonal basis. \textcolor{red}{isOrthogonalBacis} i Listing \ref{check_orthogonal_basis} tjekker om alle vektorerne i en matrix er ortogonale, ved at tjekke om søjle $v_i$ er ortogonal med $v_{i+1}$, for alle $i \in [1, n-1]$ hvor $n$ er længden på søjlerne. To søjler er ortogonale hvis deres indreprodukt er 0.

\begin{lstlisting}[
    language={FSharp}, 
    label={check_orthogonal_basis}, 
    caption={Funktion til at tjekke om søjlerne i en matrix er en ortogonal basis}
    ]
// isOrthogonalBacis : Matrix -> bool
let rec isOrthogonalBacis (M(vl, o)) =
    if not <| corectOrderCheck (M(vl, o)) C 
    then isOrthogonalBacis <| correctOrder (M(vl, o)) C
    else
    match vl with
    | [] -> true
    | _::[] -> true
    | v::vnext::vrest -> innerProduct v vnext = zero && isOrthogonalBacis (M(vnext::vrest, o))
\end{lstlisting}
%TODO: ET bevis for denne kunne være nice

PB testen \textcolor{red}{gramSchmidtIsOrthogonal} bliver derfor blot at tjekke om en matrix bestående af lineært uafhængige vektorer, der udspænder et underrum, er orthogonale efter Gram-Schmidt processen er blevet anvendt. Grundet tilfældige matematiske operationer, opstår der en støre mængde opstå overflow fejl, derfor godtages disse men klassificeres som overflow.

\begin{lstlisting}[
    language={FSharp}, 
    label={pbt_gram_schmidt}, 
    caption={PBT af Gram-Schmidt processen}
    ]
let gramSchmidtIsOrthogonal (m:IndependetBacis) =
    let res =
        try 
            if orthogonalBacis m |> isOrthogonalBacis then 1 else 0
        with
            | :? System.OverflowException -> 2
    (res = 1 || res = 2)
    |> Prop.classify (res = 1) "PropertyHolds"
    |> Prop.classify (res = 2) "OverflowException"
\end{lstlisting}

\begin{lstlisting}[
    style=output,
    label = {output_gram_schmidt},
    caption = {Output fra PBT af Gram-Schmidt processen}
]
- Arb.register<IndependetBacisGen>()
- let _ = Check.Quick gramSchmidtIsOrthogonal;;
Ok, passed 100 tests.
69% PropertyHolds.
31% OverflowException.
\end{lstlisting}

Outputtet fra PBT af Gram-Schmidt processen kan ses i Listing \ref{output_gram_schmidt}. Som sædvanligt indikere testen kun korrekthed, men ikke garanteret korrekthed.

