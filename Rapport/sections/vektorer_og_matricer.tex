\section{Vektorer og Matricer}
Vi vil nu betragte opbyggelsen af et modul for vektorer og matricer. Eftersom en vektor også kan opfattes som en matrix, vil vi i det følgende, når begge dele omtales, udelukkende referere til matricer. For systematik at kunne håndtere matricer, starter vi med at definere en type for lagringsordning Listing \ref{Order}.

\begin{lstlisting}[
    language={FSharp}, 
    label={Order}, 
    caption={Typen for order}
    ]
type Order = | R | C
\end{lstlisting}

Typen Order, anvendes til at angive, om en matrix er i rækkefølge (row-major) eller kolonnefølge (column-major)\footcitetitle{major_order}. En vektor, der er lagret i rækkefølge, kan betragtes som den transponeret kolonnefølge vektor. Vi kan derfor nu definere en type for matricer, ved hjælp af en type for vektore i Listing \ref{matrix}.

\begin{lstlisting}[
    language={FSharp}, 
    label={matrix}, 
    caption={Typen for Matricer}
    ]
type Vector = V of list<Number> * Order
type Matrix = M of list<Vector> * Order
\end{lstlisting}

Derudover er det en fordel at kunne kende dimissionen af en matrix. Derfor er der også defineret en type for dimissionen se Listing \ref{dim}.

\begin{lstlisting}[
    language={FSharp}, 
    label={dim}, 
    caption={Typen for dimissionen}
    ]
// Rows x Cols
type Dimension = D of int * int
\end{lstlisting}


\subsection{Matrix operationer}
Der vil i denne sektion beskrives en række funktioner som er nødvendige før vi kan betragte nogle funktion for anvendelse af matricer. Da modulet indeholder mange hjælpe funktioner, vil der fokuseres på de funktioner med matematisk relevans.

Det muligt at definere en funktion til at finde dimissionen af en matrix se Listing \ref{dim_func}. Funktionen laver et kald til \textcolor{red}{matrixValidMajor} som genere en fejl hvis ikke alle vektorer og matrien har samme lagringsordning. \textcolor{red}{matrixVectorLength} finder længden på vektor listen en i matricen.

\begin{lstlisting}[
    language={FSharp}, 
    label={dim_func}, 
    caption={Funktion til at finde dimissionen af en matrix}
    ]
    // dimMatrix : Matrix -> Dimension
let dimMatrix (M(vl, o)) =
    if vl = [] then D (0, 0)
    else
    let _ = matrixValidMajor (M(vl, o))
    let d1 = List.length vl
    let d2 = matrixVectorLength (M(vl, o))
    match o with
    | R -> D (d1, d2)
    | C -> D (d2, d1)
\end{lstlisting}

Hvis en matrix er gemt som rækkefølge, vil antallet af rækker være længden af en vektor og antallet af kolonner være længden af vektor listen, og omvendt for kolonnefølge.

\subsection{Matematiske operationer}
I denne sektion bør det bemærkes, at flere listings ikke inkluderer fejlhåndtering; dette er udeladt for at forbedre læsbarheden. De funktioner, der anvendes i det implementerede modul, har passende fejltjek, herunder dimensionstjek på matricerne. Den fulde implementering med fejlhåndtering kan findes i appendiks \ref{sec:matrix.fs}.

Før vi implementere funktioner til at udføre de ønskede matematiske operationer, vil vi først definere nogle egenskaber matricerne skal opfylde i egenskab \ref{vector_space_axioms}.
\vspace{0.5cm}
\begin{egenskab}[Vektor Aksiomer]\label{vector_space_axioms}
    Lad $c, d \in \mathbb{F}$ og $v_i \in \mathbb{F}^n$ for $i = 1 \dots m$ så gælder:\footcitetitle[Theorem 7.2 s. 155]{mat1a}
    \begin{enumerate}
        \item $(v_1 + \dots + v_{m-1}) + v_m = v_1 + (v_2 + \dots + v_m)$
        \item $c \cdot \left(d \cdot \begin{bmatrix}
            | &        & | \\
            v_{1} & \cdots & v_{m} \\
            | &        & | \\
        \end{bmatrix}\right) = (c \cdot d) \cdot \begin{bmatrix}
            | &        & | \\
            v_{1} & \cdots & v_{m} \\
            | &        & | \\
        \end{bmatrix}$
        
        \item $c \cdot (v_1 + \dots +v_m) = c \cdot v_1 + \dots +c \cdot v_m$
    \end{enumerate}
\end{egenskab}


\subsubsection{Skalering af en matrix}
Vi begynder med at betragte en funktion til at skalere en matrix se Listing \ref{scale_matrix}. 

\begin{lstlisting}[
    language={FSharp}, 
    label={scale_matrix}, 
    caption={Funktion til at skalere en matrix}
    ]
// scalarVector : Number -> Vector -> Vector
let scalarVector (n:Number) (V (nl, o)) = 
    V ((List.map (fun x -> x * n) nl), o)

// scalarMatrix : Matrix -> Number -> Matrix
let scalarMatrix (M (vl, o)) n = 
    M ((List.map (fun x -> scalarVector n x) vl), o)
\end{lstlisting}

Det at skalere en matrice er svare til at skalere hvert element i matricen. Derfor ved at have en funktion \textcolor{red}{scalarVector}, der skalere hvert element i en givet vektor bliver \textcolor{red}{scalarMatrix} at skalere hver vektor i en givet matrice. List.\textcolor{red}{map} svare til at lave en list comprehension i Python\footcitetitle{list_comprehension}.


\subsubsection{Addition af matricer}
\begin{lstlisting}[
    language={FSharp}, 
    label={add_matrix}, 
    caption={Funktion til at addere matricer og substraktion af vektorer}
    ]
// addVector : Vector -> Vector -> Vector
let addVector (V (v1, o1)) (V (v2, _)) =
    V ((List.map2 (+) v1 v2), o1)

// addMatrix : Matrix -> Matrix -> Matrix
let addMatrix (M(vl1, o)) (M(vl2, _)) =
    M (List.map2 addVector vl1 vl2, o)

// subVector : Vector -> Vector -> Vector
let subVector x y =
    scalarVector (-one) y |> addVector x
    
// sumRows : Matrix -> Matrix
let rec sumRows m = 
    if not <| corectOrderCheck m C 
        then sumRows <| correctOrder m C
    else
        let zeroVector = vectorOf zero <| matrixVectorLength m
        let (M(vl, _)) = m
        matrix [List.fold (addVector) zeroVector vl]
\end{lstlisting}

Addition af vektorer reduceres til at udføre additionen elementvis, som vist i Listing \ref{add_matrix}, ved brug af List-funktionen \textcolor{red}{map2}. Vi kan bruge \textcolor{red}{addVector} til at definere matrix addition og subtraktion af vektorer. Vektor addition bruges også til at summere rækkerne i en matrix (\textcolor{red}{sumRows}), hvilket vil blive anvendt i implementeringen af matrix produkt i næste sektion og Gram-Schmidt-processen i sektion \ref{sec:gram_schmidt}. Funktionen bliver yderligere beskrevet i definition \ref{sumRows}.

\vspace{0.5cm}
\begin{definition}[Summering af rækker i en matrix] \label{sumRows}
Lad $A$ være en matrix med $m$ rækker og $n$ søjler, hvor
\[
A = \begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
\]

Så gælder om \textcolor{red}{sumRows} at

\[
\textit{\textcolor{red}{sumRows}}(A) =
v = \begin{bmatrix}
\sum_{j=1}^{n} a_{1j} \\
\sum_{j=1}^{n} a_{2j} \\
\vdots \\
\sum_{j=1}^{n} a_{mj}
\end{bmatrix}
\]

Dermed er $v_i = \sum_{j=1}^{n} a_{ij}$ for $i = 1, 2, \ldots, m$.
\end{definition}

\subsubsection{Matrix produkt}


\begin{definition}[Matrix-Vektor Produkt] \label{def:matrix_vector_pro}
    Lad $A$ være en matrix med $m$ rækker og $n$ søjler, hvor
    \[
    A = \begin{bmatrix}
    a_{11} & a_{12} & \cdots & a_{1n} \\
    a_{21} & a_{22} & \cdots & a_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{m1} & a_{m2} & \cdots & a_{mn}
    \end{bmatrix}
    \]
    og $\mathbf{v} = (v_1, v_2, \ldots, v_n)^T$ være en vektor med $n$ elementer. Så er matrix-vektor $Av$ produktet defineret som
    \[
\begin{bmatrix}
    a_{11} & a_{12} & \cdots & a_{1n} \\
    a_{21} & a_{22} & \cdots & a_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
\begin{bmatrix}
    v_{1} \\
    v_{2} \\
    \vdots \\
    v_{n}
\end{bmatrix}
=
\begin{bmatrix}
    a_{11}v_{1} + a_{12}v_{2} + \cdots + a_{1n}v_{n} \\
    a_{21}v_{1} + a_{22}v_{2} + \cdots + a_{2n}v_{n} \\
    \vdots \\
    a_{m1}v_{1} + a_{m2}v_{2} + \cdots + a_{mn}v_{n}
\end{bmatrix}
= \begin{bmatrix}
    \sum_{j=1}^{n} a_{1j}v_{j} \\
    \sum_{j=1}^{n} a_{2j}v_{j} \\
    \vdots \\
    \sum_{j=1}^{n} a_{mj}v_{j}
\end{bmatrix}
\]
\end{definition}

\begin{theorem}[Matrix-Vektor Produkt] \label{matrix_vector_pro}
    Lad $A$ være en matrix med $m$ rækker og $n$ søjler, og lad $\mathbf{v}$ være en vektor med $n$ elementer. Så gælder der
    \[ Av = \textit{\textcolor{red}{sumRows}}
    \begin{bmatrix}
        | & | &        & | \\
        a_{1}v_{1} & a_{2}v_{2} & \cdots & a_{n}v_{n} \\
        | & | &        & | \\
    \end{bmatrix}
    \]
\end{theorem}
\begin{proof}
    Lad $B$ være resultatet af at skalere søjlerne i matrix $A$ med de tilsvarende elementer i vektoren $\mathbf{v}$. Vi har
    \begin{alignat*}{2}
    B &= \begin{bmatrix}
        | & | &        & | \\
        a_{1}v_{1} & a_{2}v_{2} & \cdots & a_{n}v_{n} \\
        | & | &        & | \\
    \end{bmatrix} \\
    &= \begin{bmatrix}
        a_{11}v_{1} & a_{12}v_{2} & \cdots & a_{1n}v_{n} \\
        a_{21}v_{1} & a_{22}v_{2} & \cdots & a_{2n}v_{n} \\
        \vdots & \vdots & \ddots & \vdots \\
        a_{m1}v_{1} & a_{m2}v_{2} & \cdots & a_{mn}v_{n}
    \end{bmatrix}
    \end{alignat*}
    Ved brug af definition \ref{sumRows} for \textit{\textcolor{red}{sumRows}} og definition \ref{def:matrix_vector_pro} ses det at 
    \begin{alignat*}{2}
    \text{{\color{red}\textit{sumRows}}}(B) &= \begin{bmatrix}
        \sum_{j=1}^{n} a_{1j}v_{j} \\
        \sum_{j=1}^{n} a_{2j}v_{j} \\
        \vdots \\
        \sum_{j=1}^{n} a_{mj}v_{j}
    \end{bmatrix} = A\mathbf{v}
    \end{alignat*}
\end{proof}
Vi kan dermed anvende sætning \ref{matrix_vector_pro} til at definere en funktion \textcolor{red}{matrixVectorProduct} til matrix-vektor produkt se Listing \ref{vecPro}. Denne funktion skalerer først søjlerne i matricen med de tilsvarende elementer i vektoren og summer derefter rækkerne i matricen.
\begin{lstlisting}[
    language={FSharp}, 
    label={vecPro}, 
    caption={Funktion til matrix-vektor produkt}
    ]
// matrixVectorProduct : Matrix -> Vector -> Matrix
let rec matrixVectorProduct (M(vl, _)) (V(nl, _)) =
    M (List.map2 (fun mc n -> scalarVector n mc) vl nl, C) 
    |> sumRows
\end{lstlisting}

\begin{definition}[Matrix produkt]\label{def:matrix_matrix_pro}
    Lad $A \in \mathbb{F}^{m \times n}$ og $B \in \mathbb{F}^{n \times \ell}$. Lad søjlerne i $B$ er være givet ved $b_1, \ldots, b_\ell \in \mathbb{F}^n$, dermed\footcitetitle[Definition 7.12
 s. 162]{mat1a}
    \[
        B = \begin{bmatrix}
    | &  & | \\
    b_1 & \cdots & b_\ell \\
    | &  & | \\
\end{bmatrix}.
\]
Så defineres matrixproduktet som
\[
    A \cdot B = \begin{bmatrix}
        | &  & | \\
        A \cdot b_1 & \cdots & A \cdot b_\ell \\
        | &  & | \\
    \end{bmatrix}.
    \]
\end{definition}
Ud fra definition \ref{def:matrix_matrix_pro} ses det, at funktionen \textcolor{red}{matrixProduct} i Listing \ref{pro_matrix} til at tage produktet af to matricer, ved at udfører matrix-vektor produkt på hver søjle i matricen. Da \textcolor{red}{matrixVectorProduct} evaluere til en matrix, skal der bruges en funktion til at konvertere matricen til en vektor, hvilket \textcolor{red}{matrixToVector} gør.
\begin{lstlisting}[
    language={FSharp}, 
    label={pro_matrix}, 
    caption={Funktion til at tage produktet af to matricer}
    ]
// matrixProduct : Matrix -> Matrix -> Matrix
let rec matrixProduct a (M(vlb, _)) =
    let product = List.map (
        fun bv -> matrixVectorProduct a bv |> matrixToVector ) vlb
    M(product, C)
\end{lstlisting}
        
\subsubsection{Projektion af en vektor}

\begin{definition}[Projektion af en vektor]\label{def:proj}
Projektionen af en vektor på en linje defineres i som følgende, hvor $Y = \text{span}\{y\}$\footcitetitle[s. 40]{mat1b}.
\begin{align}
    \text{proj}_Y : V \rightarrow V, \quad \text{proj}_Y(x) = \frac{\langle x, y \rangle}{\langle y, y \rangle} y
\end{align}
hvor det standard indre produkt er defineret som:
\begin{align}
    \langle x, y \rangle = y^* x = \sum_{k=1}^{n} x_k \overline{y}_k
\end{align}
\end{definition}
    

For at kunne projektere en vektor, som defineret i destination \ref{def:proj} skal vi først kunne konjugere en vektor. Funktionen \textcolor{red}{conjugateVector} konjugerer elementerne i en vektor. Derudover defineres en funktion til at multiplicere to vektorer elementvis (\textcolor{red}{vectorMulElementWise}).

\begin{lstlisting}[
    language={FSharp}, 
    label={proj_fun}, 
    caption={Funktioner til at projicere en vektor på en anden}
    ]
// vectorMulElementWise : Vector -> Vector -> Vector
let vectorMulElementWise (V(u, o1)) (V(v, o2)) =
    V (List.map2 (*) u v, o1)

// conjugateVector : Vector -> Vector
let conjugateVector (V(v, o)) = 
    V (List.map conjugate v, o)

// innerProduct : Vector -> Vector -> Number
let innerProduct u v =
    let (V(w, _)) = conjugateVector v |> vectorMulElementWise u
    List.fold (+) zero w

// proj : Vector -> Vector -> Vector   
let proj y x =
    scalarVector (innerProduct x y / innerProduct y y) y
\end{lstlisting}

Evalueringen af det standard indre produkt \textcolor{red}{innerProduct} mellem to vektore, bliver derfor at konjugere den ene vektor og derefter multiplicere elementvis med den anden vektor. Hvortil summen af elementerne i den resulterende vektor er det indre produkt.

Til sidst kan funktionen \textcolor{red}{proj} skrives direkte som den er defineret i definition \ref{def:proj}.



\subsection{Gram-Schmidt}\label{sec:gram_schmidt}
Vi kan nu betragte implementeringen af Gram-Schmidt processen. Denne proces kan anvendes rekursivt til at finde en ortonormal basis for et underrum udspændt af en liste af vektorer $v_1, v_2, \ldots, v_n$. Processen kan implementeres rekursivt idet de nye vektorer $w_k$ for $k = 2, 3, \ldots, n$ konstrueres baseret på alle de tidligere vektorer $w_1, \ldots, w_{k-1}$. 

Før vi implementerer Gram-Schmidt processen, er vi dog begrænset af vores Number type fra Listing \ref{number_type}, idet $x \in \text{\{Number\}} \centernot\implies \sqrt{x} \in \text{\{Number\}}$. Derfor vil vi ikke normalisere vektorerne, hvilket medfører, at vi kun vil finde en ortogonal basis, fremfor en ortonormal basis.

Der er også 2 egenskaber \ref{eg:gs} som vi i sektion \ref{sec:pbt_gram_schmidt} vil teste for at sikre at vores implementering af Gram-Schmidt processen er korrekt.
\vspace{0.5cm}
\begin{egenskab}[Gram-Schmidt]\label{eg:gs}
    Lad $w_1, w_2, \ldots, w_n$ være de nye vektore som er dannes udfra gram-schmidt processen på $v_1, v_2, \ldots, v_n$ som er lineært uafhængige vektorer. Så gælder der:
    \begin{enumerate}
        \item $w_1, w_2, \ldots, w_n$ er ortogonale.
        \item $w_1, w_2, \ldots, w_n$ udspænder det samme underrum som $v_1, v_2, \ldots, v_n$. dvs. \\$\text{span}\{v_1, v_2, \ldots, v_n\} = \text{span}\{w_1, w_2, \ldots, w_n\}$.
    \end{enumerate}
\end{egenskab}

\begin{lstlisting}[
    language={FSharp}, 
    label={gram_schmidt}, 
    caption={Dannelsen af en ortogonal basis, ved hjælp af Gram-Schmidt processen}
    ]
// orthogonalBacis : Matrix -> Matrix
let orthogonalBacis m =
    if not <| corectOrderCheck m C  
    then orthogonalBacis (correctOrder m C)
    else

    // Gram_Schmidt : Matrix -> (Vector list -> Matrix) -> Matrix
    let rec Gram_Schmidt vm acc_wm =
        match acc_wm [], vm with
        | x, M([], _) -> x 
        | M([], _), M(v1::vrest, o) -> 
            Gram_Schmidt (M(vrest,o)) 
            <| fun x -> extendMatrix (M([v1], C)) x 
        | M(w, _), M(vk::vrest, o) -> 
            let (V(wk, _)) = vk - sumProj w vk
            Gram_Schmidt (M(vrest,o)) 
            <| fun x -> extendMatrix (acc_wm wk) x

    // sumProj : Vector list -> Vector -> Vector
    and sumProj w vk =
        List.map (fun x -> proj x vk) w 
        |> matrix 
        |> sumRows
        |> matrixToVector
        
    Gram_Schmidt m (fun _ -> M([], C))
\end{lstlisting}

Listing \ref{gram_schmidt} viser implementeringen af Gram-Schmidt processen. Lavet udfra beskrivelse side 45 i 'Mathematics 1b'\footcitetitle[s. 45]{mat1b}.

Funktionen \textcolor{red}{\texttt{sumProj}} tager en liste med vektorer \(w\), som i Gram-Schmidt-processen er de tidligere behandlede vektorer \(w_1, \ldots, w_{k-1}\), og en vektor \(v_k\) som er den \(k\)'te vektor. $v_k$ projiceres på alle vektorerne i \(w\), hvorefter der tages summen af disse projektioner.

Funktionen \textcolor{red}{Gram\_Schmidt}, tager en matrix hvor søjlerne er de vektore som ønskes at finde en ortogonal basis for. Der udover tager den en akkumulerende funktion som indeholder de behandlede vektorer. Hvis der ikke er flere vektorer i matricen, gives den akkumulerede funktion. Hvis der ikke er nogle vektorer i akkumulatoren, tages den første vektor fra matricen og tilføjes til akkumulatoren. Hvis der er vektorer i både akkumulatoren og matricen, kaldes \textcolor{red}{sumProj} på den akkumulerede liste og den første vektor i matricen. Resultatet trækkes fra den første vektor i matricen, og dette bliver den nye vektor som tilføjes til akkumulatoren. 

Funktionen \textcolor{red}{orthogonalBacis} tager en matrix og tjekker om matricen er i kolonnefølge, hvis ikke kalder funktionen sig selv, med den korrekte lagringsordning. Ellers kaldes \textcolor{red}{Gram\_Schmidt} med matricen og en tom akkumulator. Resultatet bliver derfor en matrix med en ortogonal basis for underrummet udspændt af de givne vektorer, givet at vektorerne er lineært uafhængige.

\subsection{Række-echelon form}
I forbindelse med udførelsen af PBT til Gram-Schmidt metoden vil vi blandt andet anvende række-echelon form til at sikre os, at et sæt af vektorer er lineært uafhængige. Derfor vil vi i denne sektion betragte implementeringen af række-echelon form, ud fra "Algorithm 9 for computing a row echelon form of a matrix" angivet på side 142 af noterne til "01001 Mathematics 1a"\footcitetitle[s. 142]{mat1a}. Efter at have udført PBT af Gram-Schmidt metoden, slog den i første omgang fejl, hvilket efter nærmere undersøgelse viste sig at være grundet en mindre fejl i Algorithm 9. Linje 14 burde være "b ← the j'th entry of the i-th row of B".  Listing \ref{row_echelon} viser implementeringen af række-echelon form, lavet ud fra psudokoden "Algorithm 9".

\begin{lstlisting}[
    language={FSharp}, 
    label={row_echelon}, 
    caption={Funktion til at finde række-echelon form}
    ]
// rowEchelonForm : Matrix -> Matrix
let rec rowEchelonForm A = 
    if not <| corectOrderCheck A R then rowEchelonForm (correctOrder A R)
    else
    let (D(r, c)) = dimMatrix A
    match A with
    |M([], _) -> A
    | _ when isZeroMatrix A -> A
    | M(v::_, _) when r = 1 -> firstNonZero v |> inv |> scalarMatrix A  
    | M(_, o) ->
        let (i, j) = firstNonZeroIndexMatrix A 0 (-1 ,-1)
        let (M(B, _)) = swapFirstWith A i
        let b = List.head B |> firstNonZero
        let (M(B, _)) = scalarIthVector (inv b) 0 (M(B, o))
        let R1 = List.head B
        let R2m = List.tail B
        let B = rowOps j 1 r R1 (M(R2m, o))
        let (M(Cm, _)) = rowEchelonForm B
        M(R1::Cm, o)

// rowOps: int -> int -> int -> Vector -> Matrix -> Matrix  
and rowOps coloumn i nrows R1 acc_m  =
    if i >= nrows then acc_m else
    let Ri = getMatrixIthVector (i - 1) acc_m
    let b = getVectorIthNumber coloumn Ri
    rowOps coloumn (i + 1) nrows R1 <| replaceMatrixIthVector (i-1) acc_m (Ri - b * R1)
\end{lstlisting}

\subsection{linært lignings system}\label{sec:lin_eq}
Som den sidste del i implementerede anvendelse af matricer, vil vi beskrive hvordan vi kan løse et linært lignings system 
