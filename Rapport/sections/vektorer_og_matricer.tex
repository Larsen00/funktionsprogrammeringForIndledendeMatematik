Vi vil nu betragte et modul for vektorer og matricer. Da en Vector også kan betragtes som en matrix, vil vi herfra når der omtalles begge kun referare til en matrix. For at kunne håndtere matricer på en systematik måde begynder vi med at defienre en type for major order.

Vi vil nu betragte opbyggelsen af et modul for vektorer og matricer. Eftersom en vektor også kan opfattes som en matrix, vil vi i det følgende, når begge dele omtales, udelukkende referere til matricer. For systematik at kunne håndtere matricer, starter vi med at definere en type for lagringsordning.

\begin{lstlisting}[
    language={FSharp}, 
    label={Order}, 
    caption={Typen for order}
    ]
type Order = | R | C
\end{lstlisting}

Order Listing \ref{Order} bruges derfor til at beskrive hvor vidt en matrix er row-major eller column-major\footnote{\url{https://en.wikipedia.org/wiki/Row-_and_column-major_order}}. En vektor som er column-major vil være en transponeret row-major vektor.  

Typen Order (se Listing \ref{Order}), anvendes til at angive, om en matrix er i rækkefølge (row-major) eller kolonnefølge (column-major)\footnote{\url{https://en.wikipedia.org/wiki/Row-_and_column-major_order}}. En vektor, der er lagret i kolonnefølge, kan betragtes som den transponeret rækkefølge vektor. Vi kan derfor nu definere en type for matricer, ved hjælp af en type for vektore (Listing \ref{matrix}).

\begin{lstlisting}[
    language={FSharp}, 
    label={matrix}, 
    caption={Typen for Matricer}
    ]
type Vector = V of list<Number> * Order
type Matrix = M of list<Vector> * Order
\end{lstlisting}

Derudover er det en fordel at kunne kende dimissionen af en matrix. Derfor er der også defineret en type for dimissionen(se Listing \ref{dim}).

\begin{lstlisting}[
    language={FSharp}, 
    label={dim}, 
    caption={Typen for dimissionen}
    ]
// Rows x Cols
type Dimension = D of int * int
\end{lstlisting}

Dermed er det muligt at definere en funktion til at finde dimissionen af en matrix (se Listing \ref{dim_func}). Funktionen laver et kald til \textcolor{red}{matrixValidMajor} genere en fejl hvis ikke alle vektorer og matrien har samme lagringsordning. \textcolor{red}{matrixVectorLength} finder længden af en vektor i matricen.

\begin{lstlisting}[
    language={FSharp}, 
    label={dim_func}, 
    caption={Funktion til at finde dimissionen af en matrix}
    ]
    // dimMatrix : Matrix -> Dimension
let dimMatrix (M(vl, o)) =
    if vl = [] then D (0, 0)
    else
    let _ = matrixValidMajor (M(vl, o))
    let d1 = List.length vl
    let d2 = matrixVectorLength (M(vl, o))
    match o with
    | R -> D (d1, d2)
    | C -> D (d2, d1)
\end{lstlisting}

Hvis en matrix er gemt som rækkefølge, vil antallet af rækker være længden af en vektor og antallet af kolonner være længden af vektor listen, og omvendt for kolonnefølge.

\subsection{Matrix operationer}
Der vil i denne sektion beskrives en række funktioner som er nødvendige før vi kan betragte nogle rekursive algoritmer som kan anvendes på en matrice.

Vi begynder med at betragte en funktion til at skalere en matrix (se Listing \ref{scale_matrix}). 

\begin{lstlisting}[
    language={FSharp}, 
    label={scale_matrix}, 
    caption={Funktion til at skalere en matrix}
    ]
// scalarVector : Number -> Vector -> Vector
let scalarVector (n:Number) (V (nl, o)) = 
    V ((List.map (fun x -> x * n) nl), o)

// scalarMatrix : Matrix -> Number -> Matrix
let scalarMatrix (M (vl, o)) n = 
    M ((List.map (fun x -> scalarVector n x) vl), o)
\end{lstlisting}

Det at skalere en matrice er svare til at skalere hvert element i matricen. Derfor ved at have en funktion \textcolor{red}{scalarVector}, der skalere hvert element i en givet vektor bliver \textcolor{red}{scalarMatrix} at skalere hver vektor i en givet matrice. List.\textcolor{red}{map} svare til at lave en list comprehension i Python\footnote{\url{https://www.w3schools.com/python/python_lists_comprehension.asp}}.


\subsubsection{Projection af en vektor}
Som beskrevet i afsnit 2.3 'Projections onto a line' i 'Mathematics 1b'\footnote{Lav ref til Mathematics 1b}, kan projektionen af en vektor defineres som følgende, hvor $Y = \text{span}\{y\}$.
\begin{align}
    \text{proj}_Y : V \rightarrow V, \quad \text{proj}_Y(x) = \frac{\langle x, y \rangle}{\langle y, y \rangle} y
    \label{proj}
\end{align}
Med det standard indreprodukt 
\begin{align}
    \langle x, y \rangle = y^* x =\sum_{k=1}^{n} x_k \overline{y}_k
\end{align}

Den første funktion vi skal bruge er derfor en funktionen til at konjugere en vektor \textcolor{red}{conjugateVector}, det gøres ved at konjugere elementerne i vektoren. Udover dette defineres en funktion til at multiplikere to vektorer element vis \textcolor{red}{vectorMulElementWise}. 

\begin{lstlisting}[
    language={FSharp}, 
    label={proj_fun}, 
    caption={Funktioner til projektere en vektor på en anden}
    ]
// vectorMulElementWise : Vector -> Vector -> Vector
let vectorMulElementWise (V(u, o1)) (V(v, o2)) =
    if o1 <> o2
    then failwith "Vectors must have the same major order"
    elif List.length u <> List.length v 
    then failwith "Vectors must have the same dimension"
    else
    V (List.map2 (*) u v, o1)

// conjugateVector : Vector -> Vector
let conjugateVector (V(v, o)) = 
    V (List.map conjugate v, o)

// innerProduct : Vector -> Vector -> Number
let innerProduct u v =
    let (V(w, _)) = conjugateVector v |> vectorMulElementWise u
    List.fold (+) zero w

// proj : Vector -> Vector -> Vector   
let proj y x =
    scalarVector (innerProduct x y / innerProduct y y) y
\end{lstlisting}

Evalueringen af det standard indre produkt \textcolor{red}{innerProduct} mellem to vektore, bliver derfor at konjugere den ene vektor og derefter multiplicere elementvis med den anden vektor. Hvortil summen af elementerne i den resulterende vektor er det indre produkt.

Sidst kan funktionen \textcolor{red}{proj} skrives direkte som den er defineres i ligning \ref{proj}.


\subsection{Implementering af Gram-Schmidt}
Vi kan nu betragte implementeringen af Gram-Schmidt processen. Denne proces kan anvendes rekursivt til at finde en ortonormal basis for et underrum udspændt af en liste af vektorer $v_1, v_2, \ldots, v_n$. Processen kan implementeres rekursivt idet de nye vektorer $w_k$ for $k = 2, 3, \ldots, n$ konstrueres baseret på alle de tidligere vektorer $w_1, \ldots, w_{k-1}$. 

Før vi implementerer Gram-Schmidt processen, er vi dog begrænset af vores Number type \ref{number_type}, idet $x \in \text{\{Number\}} \centernot\implies \sqrt{x} \in \text{\{Number\}}$. Derfor vil vi ikke normalisere vektorerne, hvilket medfører, at vi kun vil finde en ortogonal basis, fremfor en ortonormal basis.

\begin{lstlisting}[
    language={FSharp}, 
    label={gram_schmidt}, 
    caption={Dannelsen af en ortogonal basis, ved hjælp af Gram-Schmidt processen}
    ]
// orthogonalBacis : Matrix -> Matrix
let orthogonalBacis m =
    if not <| corectOrderCheck m C  
    then orthogonalBacis (correctOrder m C)
    else

    // Gram_Schmidt : Matrix -> (Vector list -> Matrix) -> Matrix
    let rec Gram_Schmidt vm acc_wm =
        match acc_wm [], vm with
        | x, M([], _) -> x 
        | M([], _), M(v1::vrest, o) -> 
            Gram_Schmidt (M(vrest,o)) 
            <| fun x -> extendMatrix (M([v1], C)) x 
        | M(w, _), M(vk::vrest, o) -> 
            let (V(wk, _)) = vk - sumProj w vk
            Gram_Schmidt (M(vrest,o)) 
            <| fun x -> extendMatrix (acc_wm wk) x

    // sumProj : Vector list -> Vector -> Vector
    and sumProj w vk =
        match w with
        | [] -> vectorOf zero (vectorLength vk)
        | x::xs -> proj x vk + sumProj xs vk
        
    Gram_Schmidt m (fun _ -> M([], C))
\end{lstlisting}


Funktionen \textcolor{red}{\texttt{sumProj}} tager en liste med vektorer \(w\), som i Gram-Schmidt-processen er de tidligere behandlede vektorer \(w_1, \ldots, w_{k-1}\), og en vektor \(v_k\) som er den \(k\)'te vektor. Funktionen \textcolor{red}{\texttt{vectorOf}}, skaber en nulvektor af samme længde som \(v_k\). Når listen for \(w\) ikke er tom, projekteres det første element på \(v_k\) og adderes til resultatet af det rekursive kald til \textcolor{red}{\texttt{sumProj}} med resten af listen og \(v_k\).

Funktionen \textcolor{red}{Gram\_Schmidt}, tager en matrix hvor søjlerne er de vektores som ønskes at finde en ortogonal basis for. Der udover tager den en akkumulerende funktion som indeholder de behandlede vektorer. Hvis der ikke er flere vektorer i matricen, gives den akkumulerede funktion. Hvis der ikke er nogle vektorer i akkumulatoren, tages den første vektor fra matricen og tilføjes til akkumulatoren. Hvis der er vektorer i både akkumulatoren og matricen, kaldes \textcolor{red}{sumProj} på den akkumulerede liste og den første vektor i matricen. Resultatet trækkes fra den første vektor i matricen, og dette bliver den nye vektor som tilføjes til akkumulatoren. 

Funktionen \textcolor{red}{orthogonalBacis} tager en matrix og tjekker om matricen er i kolonnefølge, hvis ikke kalder funktionen sig selv, med den korrekte lagringsordning. Ellers kaldes \textcolor{red}{Gram\_Schmidt} med matricen og en tom akkumulator. Resultatet bliver derfor en matrix med en ortogonal basis for underrummet udspændt af de givne vektorer, givet at vektorerne er lineært uafhængige.

\subsubsection{PBT af Gram-Schmidt}
Udfrodringen ved at lave en PBT af Gram-Schmidt er at vektorsættet skal være lineært uafhængige. Derfor laves der en generator som ved at udføre tilfældige række operationer på en diagonal matrix, kan generere en matrix med lineært uafhængige vektorer. 
\#TODO : Lav et bevis for det beholder enskaben for lineært uafhængighed.

\begin{lstlisting}[
    language={FSharp}, 
    label={generators_gram_schmidt}, 
    caption={Generatorene anvendt til PBT af Gram-Schmidt}
    ]
// getBacismatrixGen : int -> Gen<Matrix>
let getBacismatrixGen n =
    Gen.map (fun x -> standardBacis x) (Gen.choose (2, n))

// performRowOperationGen : Matrix -> Gen<Matrix>
let performRowOperationGen m =
    let (D(n, _)) = dimMatrix m
    gen { 
        let! i = Gen.choose(1, n)
        let! j = match i with
            | 1 -> Gen.choose(2, n)
            | _ when i = n -> Gen.choose(1, n-1)
            | _ -> Gen.oneof [
                    Gen.choose(1, i-1); 
                    Gen.choose(i+1, n)]
        let! a = numberGen
        return rowOperation i j a m }


// multipleRowOperationsGen : Matrix -> int -> Gen<Matrix>
let rec multipleRowOperationsGen m count =
    if count <= 0 then Gen.constant m
    else
        gen {
            let! newMatrix = performRowOperationGen m
            return! multipleRowOperationsGen newMatrix (count - 1)
        }

// getIndependetBacisGen : Gen<Matrix>
let getIndependetBacisGen =
    gen { 
        let! m = getBacismatrixGen 5
        let! numberOfOperations = Gen.choose(1, 10)
        let! span = multipleRowOperationsGen m numberOfOperations
        return span }

type IndependetBacis = Matrix
type IndependetBacisGen =
    static member IndependetBacis() =
        {new Arbitrary<Matrix>() with
            override _.Generator = getIndependetBacisGen
            override _.Shrinker _ = Seq.empty}
\end{lstlisting}

Listing \ref{generators_gram_schmidt} viser de forskellige generatorer, som anvendes til PBT (Property-Based Testing) af Gram-Schmidt-processen. Først genereres en tilfældig basis matrix. Dernæst udvælges to tilfældige rækker, \(i\) og \(j\), hvorefter der udføres en rækkeoperation på \(R_j\), således at \(R_j \leftarrow R_j - aR_i\), hvor $a$ er et tilfældigt Number. Denne proces gentages et tilfældigt antal gange.

Dernæst skal vi bruge en funktion til at tjekke om en matrix er en ortogonal basis. \textcolor{red}{isOrthogonalBacis} i Listing \ref{check_orthogonal_basis} tjekker om alle vektorerne i en matrix er ortogonale, ved at tjekke om søjle $v_i$ er ortogonal med $v_{i+1}$, for alle $i \in [1, n-1]$ hvor $n$ er længden på søjlerne. To søjler er ortogonale hvis deres indreprodukt er 0.

\begin{lstlisting}[
    language={FSharp}, 
    label={check_orthogonal_basis}, 
    caption={Funktion til at tjekke om søjlerne i en matrix er en ortogonal basis}
    ]
// isOrthogonalBacis : Matrix -> bool
let rec isOrthogonalBacis (M(vl, o)) =
    if not <| corectOrderCheck (M(vl, o)) C 
    then isOrthogonalBacis <| correctOrder (M(vl, o)) C
    else
    match vl with
    | [] -> true
    | _::[] -> true
    | v::vnext::vrest -> innerProduct v vnext = zero && isOrthogonalBacis (M(vnext::vrest, o))
\end{lstlisting}

PB testen \textcolor{red}{gramSchmidtIsOrthogonal} bliver derfor blot at tjekke om en matrix bestående af lineært uafhængige vektorer, der udspænder et underrum, er orthogonale efter Gram-Schmidt processen er blevet anvendt. Grundet tilfælde matematiske operationer, opstår der en støre mængde opstå overflow fejl, derfor godtages disse men klassificeres som overflow.

\begin{lstlisting}[
    language={FSharp}, 
    label={pbt_gram_schmidt}, 
    caption={PBT af Gram-Schmidt processen}
    ]
let gramSchmidtIsOrthogonal (m:IndependetBacis) =
    let res =
        try 
            if orthogonalBacis m |> isOrthogonalBacis then 1 else 0
        with
            | :? System.OverflowException -> 2
    (res = 1 || res = 2)
    |> Prop.classify (res = 1) "PropertyHolds"
    |> Prop.classify (res = 2) "OverflowException"
\end{lstlisting}

\begin{lstlisting}[
    style=output,
    label = {output_gram_schmidt},
    caption = {Output fra PBT af Gram-Schmidt processen}
]
- Arb.register<IndependetBacisGen>()
- let _ = Check.Quick gramSchmidtIsOrthogonal;;
Ok, passed 100 tests.
69% PropertyHolds.
31% OverflowException.
\end{lstlisting}
